#delaunay.bnf - an automatic delaunay truss generator
#Michael Fenton <michaelfenton1@gmail.com>

<S> ::= <program>{}<call>
<program> ::= def mutant():{<init>{}<constants>{}<cross_brace>{}<get_genome>{}<make_truss>{}<make_all>{}<return>{}}
<init> ::= truss_graph = graph.graph(){}state = random.getstate(){}
<constants> ::= span = <span>{}depth = <depth>{}edge_list = []{}truss_graph.save_graph_info(["delaunay", span, depth]){}

<cross_brace> ::= def cross_brace():{NON_TRIANGLE = False{}top_ids = []{}bottom_ids = []{}top_list = [[0, None, 0, None, depth], [0, None, <half_span>, None, depth]]{}bottom_list = [[0, None, 0, None, 0], [0, None, <half_span>, None, 0]]{}"""Delaunay"""{}sett = [[0, random.seed(int("187")), 24000/2-random.randint(0,24000/2), random.seed(int("099")), depth-random.randint(100,depth-100)],[0, random.seed(int("382")), 24000/2-random.randint(0,24000/2), random.seed(int("664")), depth-depth],[0, random.seed(int("633")), 24000/2-random.randint(0,24000/2), random.seed(int("742")), depth-depth],[0, random.seed(int("266")), 24000/2-random.randint(0,24000/2), random.seed(int("493")), depth-random.randint(100,depth-100)],[0, random.seed(int("277")), 24000/2-random.randint(0,24000/2), random.seed(int("063")), depth-random.randint(100,depth-100)],[0, random.seed(int("117")), 24000/2-random.randint(0,24000/2), random.seed(int("669")), depth-0],[0, random.seed(int("271")), 24000/2-random.randint(0,24000/2), random.seed(int("839")), depth-0],[0, random.seed(int("840")), 24000/2-random.randint(0,24000/2), random.seed(int("440")), depth-depth],[0, random.seed(int("681")), 24000/2-24000/2, random.seed(int("550")), depth-random.randint(100,depth-100)],[0, random.seed(int("028")), 24000/2-random.randint(0,24000/2), random.seed(int("975")), depth-0],[0, random.seed(int("792")), 24000/2-24000/2, random.seed(int("613")), depth-depth],[0, random.seed(int("124")), 24000/2-random.randint(0,24000/2), random.seed(int("577")), depth-0],[0, random.seed(int("538")), 24000/2-random.randint(0,24000/2), random.seed(int("638")), depth-depth],[0, random.seed(int("111")), 24000/2-random.randint(0,24000/2), random.seed(int("005")), depth-depth],[0, random.seed(int("211")), 24000/2-random.randint(0,24000/2), random.seed(int("016")), depth-0],[0, random.seed(int("343")), 24000/2-random.randint(0,24000/2), random.seed(int("765")), depth-random.randint(100,depth-100)],[0, random.seed(int("054")), 24000/2-random.randint(0,24000/2), random.seed(int("554")), depth-0],[0, random.seed(int("570")), 24000/2-24000/2, random.seed(int("796")), depth-0],[0, random.seed(int("663")), 24000/2-random.randint(0,24000/2), random.seed(int("499")), depth-random.randint(100,depth-100)],[0, random.seed(int("990")), 24000/2-24000/2, random.seed(int("148")), depth-depth],[0, random.seed(int("763")), 24000/2-24000/2, random.seed(int("653")), depth-0],[0, random.seed(int("788")), 24000/2-random.randint(0,24000/2), random.seed(int("293")), depth-random.randint(100,depth-100)],[0, random.seed(int("197")), 24000/2-random.randint(0,24000/2), random.seed(int("150")), depth-depth],[0, random.seed(int("073")), 24000/2-24000/2, random.seed(int("135")), depth-random.randint(100,depth-100)],[0, random.seed(int("981")), 24000/2-24000/2, random.seed(int("147")), depth-depth],[0, random.seed(int("579")), 24000/2-random.randint(0,24000/2), random.seed(int("090")), depth-0],[0, random.seed(int("578")), 24000/2-random.randint(0,24000/2), random.seed(int("050")), depth-0],[0, random.seed(int("447")), 24000/2-24000/2, random.seed(int("581")), depth-random.randint(100,depth-100)],[0, random.seed(int("369")), 24000/2-random.randint(0,24000/2), random.seed(int("662")), depth-depth],[0, random.seed(int("226")), 24000/2-random.randint(0,24000/2), random.seed(int("857")), depth-0]]{}for node in top_list:{if node not in sett:{sett.append(node)}}{}for node in bottom_list:{if node not in sett:{sett.append(node)}}{}sett.sort(){}for point in sett:{node = [point[0], point[2], point[4]]{}node_id = truss_graph.add_unique_node(node, str(node))}{}new_set = []{}for node in truss_graph.node:{point = truss_graph.node[node]['xyz']{}new_set_point = [point[1], point[2]]{}new_set.append(new_set_point)}{}answer = delaunay.Triangulation(new_set){}for i, triangle in enumerate(answer.get_elements_indices()):{if len(triangle) == 3:{one = [triangle[0], triangle[1]]{}two = [triangle[1], triangle[2]]{}three = [triangle[0], triangle[2]]{}if one not in edge_list:{edge_list.append(one)}if two not in edge_list:{edge_list.append(two)}if three not in edge_list:{edge_list.append(three)}}else:{print "Non-triangle detected: ", len(triangle){}NON_TRIANGLE = True{}break}}return NON_TRIANGLE}

<get_genome> ::= def get_genome(i):{return genome[i % len(genome)]}

<make_truss> ::= def make_truss():{target = len(edge_list){}for i, edge in enumerate(edge_list):{truss_graph.add_edge(edge[0], edge[1], material=get_genome(i))}}

<span> ::= 24000
<half_span> ::= <span>/2
<depth> ::= <span>/20

<make_all> ::= NON_TRIANGLE = cross_brace(){}make_truss(){}truss_graph.sort_support_nodes(truss_graph, span){}truss_graph.sort_load_nodes(truss_graph, span, depth){}mirror_graph = truss_graph.copy_and_offset_with_mirror(truss_graph, [0, 0, 0], True){}truss_graph.replace_graph(mirror_graph){}random.setstate(state){}
<return> ::= return [truss_graph, len(edge_list), NON_TRIANGLE, False]{}
<call> ::= XXXeval_or_exec_outputXXX = mutant()
